/****************************************/
/*       HANDSHAKE CLIENT               */
/****************************************/


// int handshake(){
//     return (sendM1() != -1) & (receiveM2() != -1) & (sendM3() != -1);
// }

// int sendM1(){ /* TODO */
//     /* serialize certificate */
//     X509* certificate = cm->getCert();
//     int certificate_len;
//     unsigned char* serialized_certificate = NULL;
//     EVP_MD_CTX* ctx = EVP_MD_CTX_new();

//     /* variable for check results */
//     int ret = 0;

//     if ((certificate_len = i2d_X509(certificate, &serialized_certificate)) < 0) {
//         debug(ERROR, "[E] cannot serialize client certificate" << endl);
//         ret = -1;
//         goto ripper;
//     }

//     /* generate nonce  */
//     uint32_t nonce;

//     if (RAND_poll() != 1) { cerr << "[E] can not initialize PRNG" << endl; return -1; }
//     RAND_bytes((unsigned char*)&nonce, sizeof(nonce));

//     /* TODO -- sign nonce */
    

//     /* prepare M1 */
//     M1 m1;
//     m1.certLen = htonl(certificate_len);
//     //m1.signLen = htonl(signatureLen);
//     m1.nonceC = nonce;

//     /* send M1 */
//     connection->send((const char*)&m1, sizeof(m1));
//     connection->send((const char*)serialized_certificate, certificate_len);
//     //connection->send((const char*)signature, signatureLen);

//     debug(DEBUG, "[D] M1 + Payload" << endl);
//     hexdump(DEBUG, (const char *)&m1, sizeof(m1));
//     hexdump(DEBUG, (const char *)serialized_certificate, certificate_len);
//     //hexdump(DEBUG, (const char *)signature, signatureLen);

//     ripper:
//         OPENSSL_free(serialized_certificate);
//         EVP_MD_CTX_free(ctx);
//         return ret;
// }

// int receiveM2(){ /* TODO */
//     M2 m2;
//     connection->recv((char*)&m2, sizeof(m2));

//     /* if server sends an exagerated size for certificate or signature, don't allocate the buffers */
//     m2.certLen = ntohl(m2.certLen);
//     m2.signLen = ntohl(m2.signLen);
//     m2.encryptedSymmetricKeyLen = ntohl(m2.encryptedSymmetricKeyLen);
//     m2.ivLen = ntohl(m2.ivLen);
//     m2.keyblobLen = ntohl(m2.keyblobLen);

//     // TODO -- check too big things!!!
//     if (m2.certLen > BUFFER_SIZE) throw ExTooBig("client certificate too big");
//     if (m2.signLen > BUFFER_SIZE) throw ExTooBig("nonce signature too big");

//     //debug(DEBUG, "[D] certLen: " << m2.certLen << "\t" << "signLen: " << m2.signLen << endl);
//     debug(DEBUG, "[D] received M2" << endl);
//     hexdump(DEBUG, (const char*)&m2, sizeof(m2));

//     /* 
//         All the allocations are done here in order to be able to deallocate in one shot whenever
//         there is an error 
//     */

//     /* Allocate buffer for M2 reception */
//     unsigned char* serialized_certificate = new unsigned char[m2.certLen];
//     unsigned char* signature = new unsigned char[m2.signLen];
//     unsigned char* seal_enc_key = new unsigned char[m2.encryptedSymmetricKeyLen];
//     unsigned char* seal_iv = new unsigned char[m2.ivLen];
//     unsigned char* keyblob = new unsigned char[m2.keyblobLen];
//     iv = new unsigned char[m2.ivLen]; /* global */

//     /* Allocate ctx and buffer for plain keys */
// 	EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
//     unsigned char sharedKeys[AES128_KEY_LEN + HMAC_LEN];
//     int outLen, sharedKeyLen = 0;

//     connection->recv((char*)serialized_certificate, m2.certLen);
//     connection->recv((char*)signature, m2.signLen);
//     connection->recv((char*)seal_enc_key, m2.encryptedSymmetricKeyLen);
//     connection->recv((char*)seal_iv, m2.ivLen);
//     connection->recv((char*)keyblob, m2.keyblobLen);
//     connection->recv((char*)iv, m2.ivLen);

//     debug(DEBUG, "[D] received M2 payload" << endl);
//     hexdump(DEBUG, (const char*)serialized_certificate, m2.certLen);
//     hexdump(DEBUG, (const char*)signature, m2.signLen);
//     hexdump(DEBUG, (const char*)seal_enc_key, m2.encryptedSymmetricKeyLen);
//     hexdump(DEBUG, (const char*)seal_iv, m2.ivLen);
//     hexdump(DEBUG, (const char*)keyblob, m2.keyblobLen);
//     hexdump(DEBUG, (const char*)iv, m2.ivLen);

//     /* variable for check results */
//     int ret = 0;
    
//     /* deserialize certificate */
//     X509* server_certificate = d2i_X509(NULL, (const unsigned char**)&serialized_certificate, m2.certLen);
//     if (!server_certificate){
//         debug(ERROR, "[E] cannot deserialize server certificate" << endl);
//         ret = -1;
//         goto ripper;
//     }

//     /* check cert validity */
//     if (cm->verifyCert(server_certificate, "server") == -1) {
//         debug(ERROR, "[E] server is not authenticated by TrustedCA" << endl);
//         ret = -1;
//         goto ripper;
//     }
//     debug(INFO, "[I] server is authenticated" << endl);

//     /* TODO -- verify msg signature, now I'm verifying only the nonce 
//     if (signer->verify((char*)&(m2.nonceS), sizeof(m2.nonceS), signature, m2.signLen, cm->getPubKey()) == -1) {
//         debug(ERROR, "[E] server's nonce signature is not valid" << endl);
//         ret = -1;
//         goto ripper;
//     }
//     debug(INFO, "[I] valid nonce received from the server"<< endl);
//     */

//     /* TODO -- check nonce */
    
//     /* keys envelope decryption */
// 	if (EVP_OpenInit(ctx, EVP_aes_128_cbc(), seal_enc_key, m2.encryptedSymmetricKeyLen, seal_iv, signer->getPrivKey()) == 0){
//         debug(ERROR, "[E] EVP_OpenInit()" << endl);
//         ret = -1;
//         goto ripper;
// 	}
// 	if (EVP_OpenUpdate(ctx, (unsigned char*)&sharedKeys, &outLen, keyblob, m2.keyblobLen) == 0){
//         debug(ERROR, "[E] EVP_OpenUpdate()");
//         ret = -1;
//         goto ripper;
//     }
// 	sharedKeyLen += outLen;
//     clog << "sharedKeyLen: " << sharedKeyLen << endl;
// 	if (EVP_OpenFinal(ctx, (unsigned char*)&sharedKeys + sharedKeyLen, &outLen) == 0){
// 	    debug(ERROR, "[E] EVP_OpenFinal()");
//         ret = -1;
//         goto ripper;
// 	}
// 	sharedKeyLen += outLen;

//     /* set plain keys */
// 	sessionKey = new unsigned char[AES128_KEY_LEN];
// 	authKey = new unsigned char[HMAC_LEN];
// 	memcpy(sessionKey, sharedKeys, AES128_KEY_LEN);
// 	memcpy(authKey, sharedKeys + AES128_KEY_LEN, HMAC_LEN);

//     /* deallocations on error */
//     ripper:
//         X509_free(server_certificate);
//         delete[] serialized_certificate;
//         delete[] signature;
//         delete[] seal_enc_key;
//         delete[] seal_iv;
//         delete[] keyblob;
//         EVP_CIPHER_CTX_free(ctx);
//         return ret;
// }

// int sendM3(){
//     /* TODO */
//     return 0;
// }


/* HANDSHAKE SERVER */

// int Client::handshake(unsigned char*& session_key, unsigned char*& auth_key, unsigned char*& iv) {
//     X509* client_certificate = NULL;
//     if (receiveM1(client_certificate) == -1) throw ExCertificate("[E] M1");
//     if (sendM2(client_certificate, session_key, auth_key, iv) == -1) throw ExCertificate("[E] M2");
//     //receiveM3();
//     return 0;
// }

// int Client::receiveM1(X509*& client_certificate) {
//     /* receive M1 */
//     M1 m1;
//     connection->recv((char*)&m1, sizeof(m1));

//     /* if client sends an exagerated size for certificate or signature, don't allocate the buffers */
//     m1.certLen = ntohl(m1.certLen);
//     m1.signLen = ntohl(m1.signLen);
//     if (m1.certLen > BUFFER_SIZE) throw ExTooBig("client certificate too big");
//     if (m1.signLen > BUFFER_SIZE) throw ExTooBig("nonce signature too big");

//     debug(DEBUG, "[D] certLen: " << m1.certLen << "\t" << "signLen: " << m1.signLen << endl);

//     unsigned char* serialized_client_certificate = new unsigned char[m1.certLen];
//     connection->recv((char*)serialized_client_certificate, m1.certLen);
//     unsigned char* client_signature = new unsigned char[m1.signLen];
//     connection->recv((char*)client_signature, m1.signLen);

//     debug(DEBUG, "[D] received M1 + payload" << endl);
//     hexdump(DEBUG, (const char*)&m1, sizeof(m1));
//     hexdump(DEBUG, (const char*)serialized_client_certificate, m1.certLen);
//     hexdump(DEBUG, (const char*)client_signature, m1.signLen);

//     /* deserialize certificate */
//     client_certificate = d2i_X509(NULL, (const unsigned char**)&serialized_client_certificate, m1.certLen);
//     if (!client_certificate){
//         debug(WARNING, "[W] cannot deserialize client certificate on socket " << connection->getSocket() << endl);
//         goto ripper;
//     }

//     /* check validity */
//     if (cm->verifyCert(client_certificate, "") == -1) {
//         debug(WARNING, "[W] client is not authenticated by TrustedCA" << endl);
//         goto ripper;
//     }
//     debug(INFO, "[I] client on socket " << connection->getSocket() << " is authenticated" << endl);

//     /* TODO -- verify nonce signature 
//     if (signer->verify(client_certificate, (char*)&(m1.nonceC), sizeof(m1.nonceC), client_signature, m1.signLen) == -1) {
//         debug(WARNING, "[W] client's nonce signature is not valid" << endl);
//         goto ripper;
//     }
//     debug(INFO, "[I] valid nonce for client socket " << connection->getSocket() << endl);
//     */

//     return 0;

//     ripper: /* deallocates everything in case of an error */
//         delete[] serialized_client_certificate;
//         delete[] client_signature;
//         return -1;
// }

// int Client::sendM2(X509* client_certificate, unsigned char*& session_key, unsigned char*& auth_key, unsigned char*& iv) {
//     M2 m2;
//     EVP_PKEY *client_pubkey = X509_get_pubkey(client_certificate);
// 	if (!client_pubkey){ debug(ERROR, "cannot extract the pubkey from client certificate" << endl); return -1;}

//     /* serialize certificate */
//     X509* server_certificate = cm->getCert();
//     int server_certificate_len;
//     unsigned char* serialized_server_certificate = NULL;

//     if ((server_certificate_len = i2d_X509(server_certificate, &serialized_server_certificate)) < 0) {
//         debug(ERROR, "[E] can not serialize server certificate" << endl);
//         return -1;
//     }

//     /* generate nonce NB */
//     uint32_t nonce;

//     if (RAND_poll() != 1) { cerr << "[E] can not initialize PRNG" << endl; return -1; }
//     RAND_bytes((unsigned char*)&nonce, sizeof(nonce));

//     /* generate Ks, Ka and IV */
//     session_key = new unsigned char[AES128_KEY_LEN];
//     auth_key = new unsigned char[HMAC_LEN];
//     iv = new unsigned char[AES128_KEY_LEN];
//     RAND_bytes(session_key, AES128_KEY_LEN);
//     RAND_bytes(auth_key, HMAC_LEN);
//     RAND_bytes(iv, AES128_KEY_LEN);

//     hexdump(DEBUG, (const char*)session_key, AES128_KEY_LEN);
//     hexdump(DEBUG, (const char*)auth_key, HMAC_LEN);
//     hexdump(DEBUG, (const char*)iv, AES128_KEY_LEN);

//     /* asymmetric encrypting - ctx_e = context for encryption */
//     /* encrypt session and auth keys with client public key */

//     int seal_enc_key_len = EVP_PKEY_size(client_pubkey);
//     unsigned char* seal_enc_key = new unsigned char[seal_enc_key_len];
//     int seal_iv_len = AES128_BLOCK_LEN;//EVP_CIPHER_iv_length(EVP_aes_128_cbc());
//     unsigned char *seal_iv = new unsigned char[seal_iv_len];
//     unsigned char* keyblob = new unsigned char[AES128_KEY_LEN + HMAC_LEN + AES128_BLOCK_LEN];
//     int update_len, keyblob_len = 0;

//     debug(DEBUG, "seal_enc_key_len:\t" << seal_enc_key_len << endl);
//     debug(DEBUG, "keyblob_len:\t" << AES128_KEY_LEN + HMAC_LEN + AES128_BLOCK_LEN << endl);

//     EVP_CIPHER_CTX *ctx_e = EVP_CIPHER_CTX_new();
//     if (EVP_SealInit(ctx_e, EVP_aes_128_cbc(), &seal_enc_key, &seal_enc_key_len, seal_iv, &client_pubkey, 1) == 0){
//         debug(ERROR, "[E] EVP_SealInit()" << endl);
//         return -1;
//     }
//     EVP_SealUpdate(ctx_e, keyblob, &update_len, session_key, AES128_KEY_LEN);
//     keyblob_len += update_len;
//     EVP_SealUpdate(ctx_e, keyblob + keyblob_len, &update_len, auth_key, HMAC_LEN);
//     keyblob_len += update_len;

//     EVP_SealFinal(ctx_e, keyblob + keyblob_len, &update_len);
//     keyblob_len += update_len;
//     EVP_CIPHER_CTX_free(ctx_e);

//     debug(DEBUG, "seal_enc_key_len:\t" << seal_enc_key_len << endl);
//     debug(DEBUG, "keyblob_len:\t" << keyblob_len << endl);

//     /* signature - ctx_s = context for signing */
//     char server_signature[BUFFER_SIZE];
//     int signatureLen;

//     EVP_MD_CTX* ctx_s = EVP_MD_CTX_new();
//     EVP_SignInit(ctx_s, EVP_sha256());
//     EVP_SignUpdate(ctx_s, (unsigned char*)&nonce, sizeof(nonce));
//     EVP_SignFinal(ctx_s, (unsigned char*)server_signature, (unsigned int*)&signatureLen, signer->getPrivKey());
//     EVP_MD_CTX_free(ctx_s);

//     /* prepare M2 */
//     m2.certLen = htonl(server_certificate_len);
//     m2.signLen = htonl(signatureLen);
//     m2.encryptedSymmetricKeyLen = htonl(seal_enc_key_len);
//     m2.ivLen = htonl(seal_iv_len);
//     m2.keyblobLen = htonl(keyblob_len);
//     m2.nonceS = nonce;
//     m2.nonceC = htonl(0xcafebabe);  // TODO

//     /* send M2 */
//     connection->send((const char*)&m2, sizeof(m2));
//     connection->send((const char*)serialized_server_certificate, server_certificate_len);
//     connection->send((const char*)server_signature, signatureLen);
//     connection->send((const char*)seal_enc_key, seal_enc_key_len);
//     connection->send((const char*)seal_iv, seal_iv_len);
//     connection->send((const char*)keyblob, keyblob_len);
//     connection->send((const char*)iv, seal_iv_len);

//     debug(DEBUG, "[D] M2 Lengths" << endl);
//     debug(DEBUG, "[D] server_certificate_len:\t" << server_certificate_len << endl);
//     debug(DEBUG, "[D] signatureLen:\t" << signatureLen << endl);
//     debug(DEBUG, "[D] seal_enc_key_len:\t" << seal_enc_key_len << endl);
//     debug(DEBUG, "[D] seal_iv_len:\t" << seal_iv_len << endl);
//     debug(DEBUG, "[D] keyblob_len:\t" << keyblob_len << endl);

//     debug(DEBUG, "[D] M2 + Payload" << endl);
//     hexdump(DEBUG, (const char *)&m2, sizeof(m2));
//     hexdump(DEBUG, (const char *)serialized_server_certificate, server_certificate_len);
//     hexdump(DEBUG, (const char *)server_signature, signatureLen);
//     hexdump(DEBUG, (const char *)seal_enc_key, seal_enc_key_len);
//     hexdump(DEBUG, (const char *)seal_iv, seal_iv_len);
//     hexdump(DEBUG, (const char *)keyblob, keyblob_len);
//     hexdump(DEBUG, (const char *)iv, seal_iv_len);

//     /* free memory */
//     OPENSSL_free(serialized_server_certificate);
//     return 0;
// }